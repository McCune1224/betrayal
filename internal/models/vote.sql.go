// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vote.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVotesForTarget = `-- name: CountVotesForTarget :one
SELECT COALESCE(SUM(weight), 0)::INTEGER as total_votes
FROM vote
WHERE target_id = $1 AND cycle_day = $2 AND is_elimination = $3
`

type CountVotesForTargetParams struct {
	TargetID      int64 `json:"target_id"`
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

func (q *Queries) CountVotesForTarget(ctx context.Context, arg CountVotesForTargetParams) (int32, error) {
	row := q.db.QueryRow(ctx, countVotesForTarget, arg.TargetID, arg.CycleDay, arg.IsElimination)
	var total_votes int32
	err := row.Scan(&total_votes)
	return total_votes, err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM vote WHERE id = $1
`

func (q *Queries) DeleteVote(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVote, id)
	return err
}

const deleteVotesByCycle = `-- name: DeleteVotesByCycle :exec
DELETE FROM vote WHERE cycle_day = $1 AND is_elimination = $2
`

type DeleteVotesByCycleParams struct {
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

func (q *Queries) DeleteVotesByCycle(ctx context.Context, arg DeleteVotesByCycleParams) error {
	_, err := q.db.Exec(ctx, deleteVotesByCycle, arg.CycleDay, arg.IsElimination)
	return err
}

const getDistinctCyclesWithVotes = `-- name: GetDistinctCyclesWithVotes :many
SELECT DISTINCT cycle_day, is_elimination
FROM vote
ORDER BY cycle_day DESC, is_elimination DESC
`

type GetDistinctCyclesWithVotesRow struct {
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

func (q *Queries) GetDistinctCyclesWithVotes(ctx context.Context) ([]GetDistinctCyclesWithVotesRow, error) {
	rows, err := q.db.Query(ctx, getDistinctCyclesWithVotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDistinctCyclesWithVotesRow
	for rows.Next() {
		var i GetDistinctCyclesWithVotesRow
		if err := rows.Scan(&i.CycleDay, &i.IsElimination); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostVotedPlayer = `-- name: GetMostVotedPlayer :one
SELECT 
    target_id,
    COALESCE(SUM(weight), 0)::INTEGER as total_votes
FROM vote
GROUP BY target_id
ORDER BY total_votes DESC
LIMIT 1
`

type GetMostVotedPlayerRow struct {
	TargetID   int64 `json:"target_id"`
	TotalVotes int32 `json:"total_votes"`
}

func (q *Queries) GetMostVotedPlayer(ctx context.Context) (GetMostVotedPlayerRow, error) {
	row := q.db.QueryRow(ctx, getMostVotedPlayer)
	var i GetMostVotedPlayerRow
	err := row.Scan(&i.TargetID, &i.TotalVotes)
	return i, err
}

const getVote = `-- name: GetVote :one
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote WHERE id = $1
`

func (q *Queries) GetVote(ctx context.Context, id int32) (Vote, error) {
	row := q.db.QueryRow(ctx, getVote, id)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.VoterID,
		&i.TargetID,
		&i.CycleDay,
		&i.IsElimination,
		&i.Weight,
		&i.Context,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoteByVoterAndCycle = `-- name: GetVoteByVoterAndCycle :one
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote 
WHERE voter_id = $1 AND cycle_day = $2 AND is_elimination = $3
`

type GetVoteByVoterAndCycleParams struct {
	VoterID       int64 `json:"voter_id"`
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

func (q *Queries) GetVoteByVoterAndCycle(ctx context.Context, arg GetVoteByVoterAndCycleParams) (Vote, error) {
	row := q.db.QueryRow(ctx, getVoteByVoterAndCycle, arg.VoterID, arg.CycleDay, arg.IsElimination)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.VoterID,
		&i.TargetID,
		&i.CycleDay,
		&i.IsElimination,
		&i.Weight,
		&i.Context,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoteStatsByPlayer = `-- name: GetVoteStatsByPlayer :many
SELECT 
    target_id,
    COALESCE(SUM(weight), 0)::INTEGER as total_votes_received,
    COUNT(*) as times_voted_for
FROM vote
GROUP BY target_id
ORDER BY total_votes_received DESC
`

type GetVoteStatsByPlayerRow struct {
	TargetID           int64 `json:"target_id"`
	TotalVotesReceived int32 `json:"total_votes_received"`
	TimesVotedFor      int64 `json:"times_voted_for"`
}

func (q *Queries) GetVoteStatsByPlayer(ctx context.Context) ([]GetVoteStatsByPlayerRow, error) {
	rows, err := q.db.Query(ctx, getVoteStatsByPlayer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVoteStatsByPlayerRow
	for rows.Next() {
		var i GetVoteStatsByPlayerRow
		if err := rows.Scan(&i.TargetID, &i.TotalVotesReceived, &i.TimesVotedFor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoteTalliesByCycle = `-- name: GetVoteTalliesByCycle :many
SELECT 
    target_id,
    COALESCE(SUM(weight), 0)::INTEGER as total_votes,
    COUNT(*) as vote_count
FROM vote
WHERE cycle_day = $1 AND is_elimination = $2
GROUP BY target_id
ORDER BY total_votes DESC
`

type GetVoteTalliesByCycleParams struct {
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

type GetVoteTalliesByCycleRow struct {
	TargetID   int64 `json:"target_id"`
	TotalVotes int32 `json:"total_votes"`
	VoteCount  int64 `json:"vote_count"`
}

func (q *Queries) GetVoteTalliesByCycle(ctx context.Context, arg GetVoteTalliesByCycleParams) ([]GetVoteTalliesByCycleRow, error) {
	rows, err := q.db.Query(ctx, getVoteTalliesByCycle, arg.CycleDay, arg.IsElimination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVoteTalliesByCycleRow
	for rows.Next() {
		var i GetVoteTalliesByCycleRow
		if err := rows.Scan(&i.TargetID, &i.TotalVotes, &i.VoteCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoterParticipation = `-- name: GetVoterParticipation :many
SELECT 
    voter_id,
    COUNT(*) as votes_cast
FROM vote
GROUP BY voter_id
ORDER BY votes_cast DESC
`

type GetVoterParticipationRow struct {
	VoterID   int64 `json:"voter_id"`
	VotesCast int64 `json:"votes_cast"`
}

func (q *Queries) GetVoterParticipation(ctx context.Context) ([]GetVoterParticipationRow, error) {
	rows, err := q.db.Query(ctx, getVoterParticipation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVoterParticipationRow
	for rows.Next() {
		var i GetVoterParticipationRow
		if err := rows.Scan(&i.VoterID, &i.VotesCast); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllVotes = `-- name: ListAllVotes :many
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote
ORDER BY cycle_day DESC, is_elimination DESC, updated_at DESC
`

func (q *Queries) ListAllVotes(ctx context.Context) ([]Vote, error) {
	rows, err := q.db.Query(ctx, listAllVotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vote
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.VoterID,
			&i.TargetID,
			&i.CycleDay,
			&i.IsElimination,
			&i.Weight,
			&i.Context,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVotesByCycle = `-- name: ListVotesByCycle :many
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote 
WHERE cycle_day = $1 AND is_elimination = $2
ORDER BY updated_at DESC
`

type ListVotesByCycleParams struct {
	CycleDay      int32 `json:"cycle_day"`
	IsElimination bool  `json:"is_elimination"`
}

func (q *Queries) ListVotesByCycle(ctx context.Context, arg ListVotesByCycleParams) ([]Vote, error) {
	rows, err := q.db.Query(ctx, listVotesByCycle, arg.CycleDay, arg.IsElimination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vote
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.VoterID,
			&i.TargetID,
			&i.CycleDay,
			&i.IsElimination,
			&i.Weight,
			&i.Context,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVotesByTarget = `-- name: ListVotesByTarget :many
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote 
WHERE target_id = $1
ORDER BY cycle_day DESC, is_elimination DESC
`

func (q *Queries) ListVotesByTarget(ctx context.Context, targetID int64) ([]Vote, error) {
	rows, err := q.db.Query(ctx, listVotesByTarget, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vote
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.VoterID,
			&i.TargetID,
			&i.CycleDay,
			&i.IsElimination,
			&i.Weight,
			&i.Context,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVotesByVoter = `-- name: ListVotesByVoter :many
SELECT id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at FROM vote 
WHERE voter_id = $1
ORDER BY cycle_day DESC, is_elimination DESC
`

func (q *Queries) ListVotesByVoter(ctx context.Context, voterID int64) ([]Vote, error) {
	rows, err := q.db.Query(ctx, listVotesByVoter, voterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vote
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.VoterID,
			&i.TargetID,
			&i.CycleDay,
			&i.IsElimination,
			&i.Weight,
			&i.Context,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVote = `-- name: UpsertVote :one
INSERT INTO vote (voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (voter_id, cycle_day, is_elimination)
DO UPDATE SET 
    target_id = EXCLUDED.target_id,
    weight = EXCLUDED.weight,
    context = EXCLUDED.context,
    updated_at = NOW()
RETURNING id, voter_id, target_id, cycle_day, is_elimination, weight, context, created_at, updated_at
`

type UpsertVoteParams struct {
	VoterID       int64       `json:"voter_id"`
	TargetID      int64       `json:"target_id"`
	CycleDay      int32       `json:"cycle_day"`
	IsElimination bool        `json:"is_elimination"`
	Weight        int32       `json:"weight"`
	Context       pgtype.Text `json:"context"`
}

func (q *Queries) UpsertVote(ctx context.Context, arg UpsertVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, upsertVote,
		arg.VoterID,
		arg.TargetID,
		arg.CycleDay,
		arg.IsElimination,
		arg.Weight,
		arg.Context,
	)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.VoterID,
		&i.TargetID,
		&i.CycleDay,
		&i.IsElimination,
		&i.Weight,
		&i.Context,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wipeAllVotes = `-- name: WipeAllVotes :exec
DELETE FROM vote
`

func (q *Queries) WipeAllVotes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, wipeAllVotes)
	return err
}
