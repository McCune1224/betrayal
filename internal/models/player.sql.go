// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: player.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO player (id, role_id, alive, coins, coin_bonus, luck, alignment) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type CreatePlayerParams struct {
	ID        int64          `json:"id"`
	RoleID    pgtype.Int4    `json:"role_id"`
	Alive     bool           `json:"alive"`
	Coins     int32          `json:"coins"`
	CoinBonus pgtype.Numeric `json:"coin_bonus"`
	Luck      int32          `json:"luck"`
	Alignment Alignment      `json:"alignment"`
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.ID,
		arg.RoleID,
		arg.Alive,
		arg.Coins,
		arg.CoinBonus,
		arg.Luck,
		arg.Alignment,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
delete from player
where id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getPlayer = `-- name: GetPlayer :one
select id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
from player
where id = $1
`

func (q *Queries) GetPlayer(ctx context.Context, id int64) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayer, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const getPlayerInventory = `-- name: GetPlayerInventory :one
select
    player.id, player.role_id, player.alive, player.coins, player.coin_bonus, player.luck, player.item_limit, player.alignment,
    array_agg(distinct ability_info.*) as ability_details,
    array_agg(distinct item.*) as item_details,
    array_agg(distinct "status".*) as immunity_details
from player
inner join player_ability on player.id = player_ability.player_id
inner join ability_info on player_ability.ability_id = ability_info.id
left join player_item on player.id = player_item.player_id
left join item on player_item.item_id = item.id
left join player_immunity on player.id = player_immunity.player_id
left join status on player_immunity.status_id = status.id
where player.id = $1
group by player.id
`

type GetPlayerInventoryRow struct {
	ID              int64          `json:"id"`
	RoleID          pgtype.Int4    `json:"role_id"`
	Alive           bool           `json:"alive"`
	Coins           int32          `json:"coins"`
	CoinBonus       pgtype.Numeric `json:"coin_bonus"`
	Luck            int32          `json:"luck"`
	ItemLimit       int32          `json:"item_limit"`
	Alignment       Alignment      `json:"alignment"`
	AbilityDetails  interface{}    `json:"ability_details"`
	ItemDetails     interface{}    `json:"item_details"`
	ImmunityDetails interface{}    `json:"immunity_details"`
}

func (q *Queries) GetPlayerInventory(ctx context.Context, id int64) (GetPlayerInventoryRow, error) {
	row := q.db.QueryRow(ctx, getPlayerInventory, id)
	var i GetPlayerInventoryRow
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
		&i.AbilityDetails,
		&i.ItemDetails,
		&i.ImmunityDetails,
	)
	return i, err
}

const listAllPlayerNotes = `-- name: ListAllPlayerNotes :many
select player_id, note_id, position, info, updated_at
from player_note
`

func (q *Queries) ListAllPlayerNotes(ctx context.Context) ([]PlayerNote, error) {
	rows, err := q.db.Query(ctx, listAllPlayerNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerNote
	for rows.Next() {
		var i PlayerNote
		if err := rows.Scan(
			&i.PlayerID,
			&i.NoteID,
			&i.Position,
			&i.Info,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayer = `-- name: ListPlayer :many
select id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
from player
`

func (q *Queries) ListPlayer(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.Alive,
			&i.Coins,
			&i.CoinBonus,
			&i.Luck,
			&i.ItemLimit,
			&i.Alignment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayerLifeboard = `-- name: ListPlayerLifeboard :many
select id, alive
from player
`

type ListPlayerLifeboardRow struct {
	ID    int64 `json:"id"`
	Alive bool  `json:"alive"`
}

func (q *Queries) ListPlayerLifeboard(ctx context.Context) ([]ListPlayerLifeboardRow, error) {
	rows, err := q.db.Query(ctx, listPlayerLifeboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPlayerLifeboardRow
	for rows.Next() {
		var i ListPlayerLifeboardRow
		if err := rows.Scan(&i.ID, &i.Alive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playerFoo = `-- name: PlayerFoo :one
select
    player.id,
    player.role_id,
    player.alive,
    player.coins,
    player.luck,
    player.item_limit,
    player.alignment,
    json_agg(
        json_build_object(
            'ability_id',
            ability_info.id,
            'name',
            ability_info.name,
            'description',
            ability_info.description
        )
    ) as ability_details,
    json_agg(
        json_build_object(
            'item_id', item.id, 'name', item.name, 'description', item.description
        )
    ) as item_details,
    json_agg(
        json_build_object(
            'immunity_id',
            status.id,
            'name',
            status.name,
            'description',
            status.description
        )
    ) as immunity_details
from player
left join player_ability on player.id = player_ability.player_id
left join ability_info on player_ability.ability_id = ability_info.id
left join player_item on player.id = player_item.player_id
left join item on player_item.item_id = item.id
left join player_immunity on player.id = player_immunity.player_id
left join status on player_immunity.status_id = status.id
where player.id = $1
group by player.id
`

type PlayerFooRow struct {
	ID              int64       `json:"id"`
	RoleID          pgtype.Int4 `json:"role_id"`
	Alive           bool        `json:"alive"`
	Coins           int32       `json:"coins"`
	Luck            int32       `json:"luck"`
	ItemLimit       int32       `json:"item_limit"`
	Alignment       Alignment   `json:"alignment"`
	AbilityDetails  []byte      `json:"ability_details"`
	ItemDetails     []byte      `json:"item_details"`
	ImmunityDetails []byte      `json:"immunity_details"`
}

func (q *Queries) PlayerFoo(ctx context.Context, id int64) (PlayerFooRow, error) {
	row := q.db.QueryRow(ctx, playerFoo, id)
	var i PlayerFooRow
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
		&i.AbilityDetails,
		&i.ItemDetails,
		&i.ImmunityDetails,
	)
	return i, err
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE player SET role_id = $2, alive = $3, coins = $4, coin_bonus = $5, luck = $6, item_limit = $7, alignment = $8 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerParams struct {
	ID        int64          `json:"id"`
	RoleID    pgtype.Int4    `json:"role_id"`
	Alive     bool           `json:"alive"`
	Coins     int32          `json:"coins"`
	CoinBonus pgtype.Numeric `json:"coin_bonus"`
	Luck      int32          `json:"luck"`
	ItemLimit int32          `json:"item_limit"`
	Alignment Alignment      `json:"alignment"`
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayer,
		arg.ID,
		arg.RoleID,
		arg.Alive,
		arg.Coins,
		arg.CoinBonus,
		arg.Luck,
		arg.ItemLimit,
		arg.Alignment,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerAlignment = `-- name: UpdatePlayerAlignment :one
UPDATE player SET alignment = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerAlignmentParams struct {
	ID        int64     `json:"id"`
	Alignment Alignment `json:"alignment"`
}

func (q *Queries) UpdatePlayerAlignment(ctx context.Context, arg UpdatePlayerAlignmentParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerAlignment, arg.ID, arg.Alignment)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerAlive = `-- name: UpdatePlayerAlive :one
UPDATE player SET alive = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerAliveParams struct {
	ID    int64 `json:"id"`
	Alive bool  `json:"alive"`
}

func (q *Queries) UpdatePlayerAlive(ctx context.Context, arg UpdatePlayerAliveParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerAlive, arg.ID, arg.Alive)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerCoinBonus = `-- name: UpdatePlayerCoinBonus :one
UPDATE player SET coin_bonus = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerCoinBonusParams struct {
	ID        int64          `json:"id"`
	CoinBonus pgtype.Numeric `json:"coin_bonus"`
}

func (q *Queries) UpdatePlayerCoinBonus(ctx context.Context, arg UpdatePlayerCoinBonusParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerCoinBonus, arg.ID, arg.CoinBonus)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerCoins = `-- name: UpdatePlayerCoins :one
UPDATE player SET coins = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerCoinsParams struct {
	ID    int64 `json:"id"`
	Coins int32 `json:"coins"`
}

func (q *Queries) UpdatePlayerCoins(ctx context.Context, arg UpdatePlayerCoinsParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerCoins, arg.ID, arg.Coins)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerItemLimit = `-- name: UpdatePlayerItemLimit :one
UPDATE player SET item_limit = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerItemLimitParams struct {
	ID        int64 `json:"id"`
	ItemLimit int32 `json:"item_limit"`
}

func (q *Queries) UpdatePlayerItemLimit(ctx context.Context, arg UpdatePlayerItemLimitParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerItemLimit, arg.ID, arg.ItemLimit)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerLuck = `-- name: UpdatePlayerLuck :one
UPDATE player SET luck = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerLuckParams struct {
	ID   int64 `json:"id"`
	Luck int32 `json:"luck"`
}

func (q *Queries) UpdatePlayerLuck(ctx context.Context, arg UpdatePlayerLuckParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerLuck, arg.ID, arg.Luck)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}

const updatePlayerRole = `-- name: UpdatePlayerRole :one
UPDATE player SET role_id = $2 WHERE id = $1 RETURNING id, role_id, alive, coins, coin_bonus, luck, item_limit, alignment
`

type UpdatePlayerRoleParams struct {
	ID     int64       `json:"id"`
	RoleID pgtype.Int4 `json:"role_id"`
}

func (q *Queries) UpdatePlayerRole(ctx context.Context, arg UpdatePlayerRoleParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayerRole, arg.ID, arg.RoleID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.Alive,
		&i.Coins,
		&i.CoinBonus,
		&i.Luck,
		&i.ItemLimit,
		&i.Alignment,
	)
	return i, err
}
