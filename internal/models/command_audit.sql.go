// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: command_audit.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCommandAuditByCorrelationID = `-- name: GetCommandAuditByCorrelationID :one
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE correlation_id = $1
`

func (q *Queries) GetCommandAuditByCorrelationID(ctx context.Context, correlationID pgtype.UUID) (CommandAudit, error) {
	row := q.db.QueryRow(ctx, getCommandAuditByCorrelationID, correlationID)
	var i CommandAudit
	err := row.Scan(
		&i.ID,
		&i.CorrelationID,
		&i.Timestamp,
		&i.CommandName,
		&i.UserID,
		&i.Username,
		&i.UserRoles,
		&i.GuildID,
		&i.ChannelID,
		&i.IsAdmin,
		&i.CommandArguments,
		&i.Status,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.Environment,
	)
	return i, err
}

const insertCommandAudit = `-- name: InsertCommandAudit :exec
INSERT INTO command_audit (
    correlation_id,
    command_name,
    user_id,
    username,
    user_roles,
    guild_id,
    channel_id,
    is_admin,
    command_arguments,
    status,
    error_message,
    execution_time_ms,
    environment
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type InsertCommandAuditParams struct {
	CorrelationID    pgtype.UUID `json:"correlation_id"`
	CommandName      string      `json:"command_name"`
	UserID           string      `json:"user_id"`
	Username         string      `json:"username"`
	UserRoles        []string    `json:"user_roles"`
	GuildID          pgtype.Text `json:"guild_id"`
	ChannelID        pgtype.Text `json:"channel_id"`
	IsAdmin          pgtype.Bool `json:"is_admin"`
	CommandArguments []byte      `json:"command_arguments"`
	Status           pgtype.Text `json:"status"`
	ErrorMessage     pgtype.Text `json:"error_message"`
	ExecutionTimeMs  pgtype.Int4 `json:"execution_time_ms"`
	Environment      pgtype.Text `json:"environment"`
}

func (q *Queries) InsertCommandAudit(ctx context.Context, arg InsertCommandAuditParams) error {
	_, err := q.db.Exec(ctx, insertCommandAudit,
		arg.CorrelationID,
		arg.CommandName,
		arg.UserID,
		arg.Username,
		arg.UserRoles,
		arg.GuildID,
		arg.ChannelID,
		arg.IsAdmin,
		arg.CommandArguments,
		arg.Status,
		arg.ErrorMessage,
		arg.ExecutionTimeMs,
		arg.Environment,
	)
	return err
}

const listAdminCommands = `-- name: ListAdminCommands :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE is_admin = true
ORDER BY timestamp DESC
LIMIT $1
`

func (q *Queries) ListAdminCommands(ctx context.Context, limit int32) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listAdminCommands, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommandAuditByCommand = `-- name: ListCommandAuditByCommand :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE command_name = $1
ORDER BY timestamp DESC
LIMIT $2
`

type ListCommandAuditByCommandParams struct {
	CommandName string `json:"command_name"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) ListCommandAuditByCommand(ctx context.Context, arg ListCommandAuditByCommandParams) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listCommandAuditByCommand, arg.CommandName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommandAuditByUser = `-- name: ListCommandAuditByUser :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE user_id = $1
ORDER BY timestamp DESC
LIMIT $2
`

type ListCommandAuditByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) ListCommandAuditByUser(ctx context.Context, arg ListCommandAuditByUserParams) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listCommandAuditByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentCommands = `-- name: ListRecentCommands :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE timestamp > NOW() - INTERVAL '1 hour'
ORDER BY timestamp DESC
LIMIT 100
`

func (q *Queries) ListRecentCommands(ctx context.Context) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listRecentCommands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
