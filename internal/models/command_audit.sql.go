// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: command_audit.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCommandActivitySummary = `-- name: GetCommandActivitySummary :one
WITH last_hour AS (
    SELECT COUNT(*) AS total
    FROM command_audit
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
last_day AS (
    SELECT
        COUNT(*) AS total,
        COUNT(*) FILTER (WHERE status = 'success') AS successes,
        COUNT(*) FILTER (WHERE status != 'success') AS failures,
        COUNT(*) FILTER (WHERE is_admin) AS admin_commands,
        COALESCE(AVG(execution_time_ms), 0) AS avg_execution_time_ms
    FROM command_audit
    WHERE timestamp >= NOW() - INTERVAL '24 hours'
)
SELECT
    COALESCE(last_hour.total, 0) AS commands_last_hour,
    COALESCE(last_day.total, 0) AS commands_last_24h,
    COALESCE(last_day.successes, 0) AS success_count_last_24h,
    COALESCE(last_day.failures, 0) AS failure_count_last_24h,
    COALESCE(last_day.admin_commands, 0) AS admin_commands_last_24h,
    COALESCE(last_day.avg_execution_time_ms, 0) AS avg_execution_time_ms_last_24h
FROM last_hour,
     last_day
`

type GetCommandActivitySummaryRow struct {
	CommandsLastHour          int64       `json:"commands_last_hour"`
	CommandsLast24h           int64       `json:"commands_last_24h"`
	SuccessCountLast24h       int64       `json:"success_count_last_24h"`
	FailureCountLast24h       int64       `json:"failure_count_last_24h"`
	AdminCommandsLast24h      int64       `json:"admin_commands_last_24h"`
	AvgExecutionTimeMsLast24h interface{} `json:"avg_execution_time_ms_last_24h"`
}

func (q *Queries) GetCommandActivitySummary(ctx context.Context) (GetCommandActivitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getCommandActivitySummary)
	var i GetCommandActivitySummaryRow
	err := row.Scan(
		&i.CommandsLastHour,
		&i.CommandsLast24h,
		&i.SuccessCountLast24h,
		&i.FailureCountLast24h,
		&i.AdminCommandsLast24h,
		&i.AvgExecutionTimeMsLast24h,
	)
	return i, err
}

const getCommandAuditByCorrelationID = `-- name: GetCommandAuditByCorrelationID :one
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE correlation_id = $1
`

func (q *Queries) GetCommandAuditByCorrelationID(ctx context.Context, correlationID pgtype.UUID) (CommandAudit, error) {
	row := q.db.QueryRow(ctx, getCommandAuditByCorrelationID, correlationID)
	var i CommandAudit
	err := row.Scan(
		&i.ID,
		&i.CorrelationID,
		&i.Timestamp,
		&i.CommandName,
		&i.UserID,
		&i.Username,
		&i.UserRoles,
		&i.GuildID,
		&i.ChannelID,
		&i.IsAdmin,
		&i.CommandArguments,
		&i.Status,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.Environment,
	)
	return i, err
}

const insertCommandAudit = `-- name: InsertCommandAudit :exec
INSERT INTO command_audit (
    correlation_id,
    command_name,
    user_id,
    username,
    user_roles,
    guild_id,
    channel_id,
    is_admin,
    command_arguments,
    status,
    error_message,
    execution_time_ms,
    environment
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type InsertCommandAuditParams struct {
	CorrelationID    pgtype.UUID `json:"correlation_id"`
	CommandName      string      `json:"command_name"`
	UserID           string      `json:"user_id"`
	Username         string      `json:"username"`
	UserRoles        []string    `json:"user_roles"`
	GuildID          pgtype.Text `json:"guild_id"`
	ChannelID        pgtype.Text `json:"channel_id"`
	IsAdmin          pgtype.Bool `json:"is_admin"`
	CommandArguments []byte      `json:"command_arguments"`
	Status           pgtype.Text `json:"status"`
	ErrorMessage     pgtype.Text `json:"error_message"`
	ExecutionTimeMs  pgtype.Int4 `json:"execution_time_ms"`
	Environment      pgtype.Text `json:"environment"`
}

func (q *Queries) InsertCommandAudit(ctx context.Context, arg InsertCommandAuditParams) error {
	_, err := q.db.Exec(ctx, insertCommandAudit,
		arg.CorrelationID,
		arg.CommandName,
		arg.UserID,
		arg.Username,
		arg.UserRoles,
		arg.GuildID,
		arg.ChannelID,
		arg.IsAdmin,
		arg.CommandArguments,
		arg.Status,
		arg.ErrorMessage,
		arg.ExecutionTimeMs,
		arg.Environment,
	)
	return err
}

const listAdminCommands = `-- name: ListAdminCommands :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE is_admin = true
ORDER BY timestamp DESC
LIMIT $1
`

func (q *Queries) ListAdminCommands(ctx context.Context, limit int32) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listAdminCommands, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommandAuditByCommand = `-- name: ListCommandAuditByCommand :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE command_name = $1
ORDER BY timestamp DESC
LIMIT $2
`

type ListCommandAuditByCommandParams struct {
	CommandName string `json:"command_name"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) ListCommandAuditByCommand(ctx context.Context, arg ListCommandAuditByCommandParams) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listCommandAuditByCommand, arg.CommandName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommandAuditByUser = `-- name: ListCommandAuditByUser :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE user_id = $1
ORDER BY timestamp DESC
LIMIT $2
`

type ListCommandAuditByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) ListCommandAuditByUser(ctx context.Context, arg ListCommandAuditByUserParams) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listCommandAuditByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentCommandErrors = `-- name: ListRecentCommandErrors :many
SELECT
    correlation_id,
    command_name,
    user_id,
    username,
    error_message,
    status,
    timestamp
FROM command_audit
WHERE status != 'success'
ORDER BY timestamp DESC
LIMIT $1
`

type ListRecentCommandErrorsRow struct {
	CorrelationID pgtype.UUID      `json:"correlation_id"`
	CommandName   string           `json:"command_name"`
	UserID        string           `json:"user_id"`
	Username      string           `json:"username"`
	ErrorMessage  pgtype.Text      `json:"error_message"`
	Status        pgtype.Text      `json:"status"`
	Timestamp     pgtype.Timestamp `json:"timestamp"`
}

func (q *Queries) ListRecentCommandErrors(ctx context.Context, limit int32) ([]ListRecentCommandErrorsRow, error) {
	rows, err := q.db.Query(ctx, listRecentCommandErrors, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentCommandErrorsRow
	for rows.Next() {
		var i ListRecentCommandErrorsRow
		if err := rows.Scan(
			&i.CorrelationID,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.ErrorMessage,
			&i.Status,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentCommands = `-- name: ListRecentCommands :many
SELECT id, correlation_id, timestamp, command_name, user_id, username, user_roles, guild_id, channel_id, is_admin, command_arguments, status, error_message, execution_time_ms, environment
FROM command_audit
WHERE timestamp > NOW() - INTERVAL '1 hour'
ORDER BY timestamp DESC
LIMIT 100
`

func (q *Queries) ListRecentCommands(ctx context.Context) ([]CommandAudit, error) {
	rows, err := q.db.Query(ctx, listRecentCommands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommandAudit
	for rows.Next() {
		var i CommandAudit
		if err := rows.Scan(
			&i.ID,
			&i.CorrelationID,
			&i.Timestamp,
			&i.CommandName,
			&i.UserID,
			&i.Username,
			&i.UserRoles,
			&i.GuildID,
			&i.ChannelID,
			&i.IsAdmin,
			&i.CommandArguments,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.Environment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopCommandsLastHour = `-- name: ListTopCommandsLastHour :many
SELECT
    command_name,
    COUNT(*) AS usage_count,
    COUNT(*) FILTER (WHERE status != 'success') AS failure_count,
    MAX(timestamp) AS last_used_at
FROM command_audit
WHERE timestamp >= NOW() - INTERVAL '1 hour'
GROUP BY command_name
ORDER BY usage_count DESC, command_name
LIMIT $1
`

type ListTopCommandsLastHourRow struct {
	CommandName  string      `json:"command_name"`
	UsageCount   int64       `json:"usage_count"`
	FailureCount int64       `json:"failure_count"`
	LastUsedAt   interface{} `json:"last_used_at"`
}

func (q *Queries) ListTopCommandsLastHour(ctx context.Context, limit int32) ([]ListTopCommandsLastHourRow, error) {
	rows, err := q.db.Query(ctx, listTopCommandsLastHour, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopCommandsLastHourRow
	for rows.Next() {
		var i ListTopCommandsLastHourRow
		if err := rows.Scan(
			&i.CommandName,
			&i.UsageCount,
			&i.FailureCount,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
