Title: /tarot Slash Command â€“ Plan

Overview
- Add a new slash command `/tarot` that draws a tarot card using existing data in `internal/commands/tarot/cards.go`.
- Support four draw variants selectable via an option: deterministic (default), per-user assignment, guild deck (no replacement), and random.
- Follow established ken.SlashCommand patterns (struct with `Initialize`, compile-time interface assertion, `Options`, `Run`, subcommand handlers, panic recovery with logger).
- Keep initial UX simple and fast; DB persistence is optional; default plan avoids DB and uses deterministic hashing or in-memory state.

Foundation
- Data: `internal/commands/tarot/cards.go`
  - `TarotCardOptions [...]string` â€“ card names (index-aligned)
  - `TarotUprightOptions [...]string` â€“ upright meanings (index-aligned)
  - `TarotReverseOptions [...]string` â€“ reversed meanings (index-aligned)
- Command skeleton reference: `internal/commands/echo/echo.go`
- Registration pattern: add `new(tarot.Tarot)` in `cmd/betrayal-bot/main.go` registration list.

Scope & Defaults (per userâ€™s answer)
- Implement all four modes; default to deterministic by guild+user hash.
- Orientation: derived deterministically from hash in deterministic mode; random in random mode; persisted or in-memory per chosen mode when applicable; allow optional `reversed` flag to force orientation.
- Persistence: initial implementation avoids DB; per-user and guild-deck modes use in-memory state with admin reset. If long-term persistence is desired, we can add DB migrations later (see Optional DB Persistence).

Design
- Command: `/tarot`
  - Subcommands
    - `draw` â€“ perform a card draw in one of four modes; options:
      - `mode` (string choice, optional; default `deterministic`): `deterministic`, `per_user`, `guild_deck`, `random`
      - `reversed` (bool, optional): force reversed orientation when true
    - `reset` (admin-only): clear in-memory state; options:
      - `scope` (string choice, required): `per_user`, `guild_deck`, `all`
      - `user` (user, optional): required when `scope=per_user` to clear a specific userâ€™s assignment
- Response: use `internal/discord/text.go` helpers to send an embed with:
  - Title: `ðŸ”® <Card Name>` plus ` (Reversed)` when reversed
  - Description: meaning text (upright or reversed) from `cards.go`
  - Footer: mentions the caller and shows EST timestamp (reuse util.GetEstTimeStamp() if needed or simple time.Now())
- Behavior by mode:
  - `deterministic` (default): compute `idx = fnv64(guildID+":"+userID) % len(TarotCardOptions)`; `reversed = (fnv64(guildID+":"+userID+"/rev") & 1) == 1` unless overridden by flag.
  - `random`: uniformly sample `idx` from range; `reversed` as `rand.Intn(2)==1` unless overridden.
  - `per_user`: store user -> (idx, reversed) mapping per guild in memory; if present, return stored; if absent, assign random and store; allow forced `reversed` override at draw time without mutating stored orientation unless we decide to update (default: do not mutate on override).
  - `guild_deck`: maintain a per-guild set of dealt indices; draw randomly from remaining; if empty, return message prompting admin reset; track reversed randomly at deal time (store alongside index) unless overridden at response time (override does not mutate stored orientation by default).

Optional DB Persistence (phase 2)
- If you want persistence across bot restarts:
  - Per-user assignments: table `tarot_user_card(guild_id, user_id, card_index, reversed, assigned_at, PRIMARY KEY(guild_id,user_id))`
  - Guild deck: table `tarot_deck_deal(guild_id, card_index, reversed, dealt_at, PRIMARY KEY(guild_id,card_index))`
  - Add migrations under `internal/db/migration/` and sqlc queries under `internal/models/` to match project conventions.
  - The command handlers will swap in sqlc-backed lookups/inserts instead of in-memory maps.

No-DB Fallback (if persistence is not desired)
- Deterministic assignment from `(guild_id,user_id)` hash modulo `len(TarotCardOptions)`; reversed randomized or derived from hash parity.
- Pros: no migrations; Cons: cannot â€œresetâ€ or change assignment without changing algorithm; potential collisions across users are acceptable under "personal assignment" interpretation.

Implementation Steps
1) Add command implementation
   - File: `internal/commands/tarot/tarot.go`
   - Struct: `type Tarot struct { dbPool *pgxpool.Pool }` plus package-level in-memory stores:
     - `var userAssignments map[string]map[string]assignment` guarded by `sync.RWMutex` (outer key: guildID, inner: userID)
     - `var guildDeck map[string]deckState` guarded by `sync.RWMutex` (key: guildID; value tracks remaining indices and dealt map/index->reversed)
   - Methods: `Initialize`, `Name`, `Description`, `Version`, `Options`, `Run`
   - Subcommand handlers: `draw`, `reset`
   - Deterministic hashing: use `hash/fnv` (FNV-1a 64)
   - Compose embed via `ctx.RespondEmbed` or `discord.SuccessfulMessage`

2) Registration
   - Import package in `cmd/betrayal-bot/main.go`
   - Add `new(tarot.Tarot)` to registration list.

3) (Optional phase 2) DB persistence
   - Add migrations for `tarot_user_card` and `tarot_deck_deal`
   - Add sqlc query file(s) under `internal/models/` for CRUD
   - Swap in DB lookups/inserts in handlers behind small helper functions; keep in-memory as fallback when DB rows not found.

4) Admin Gate
   - For `reset`, require admin roles using `discord.IsAdminRole` and return `discord.NotAdminError` if unauthorized.

Verification
- Build: `go build ./cmd/betrayal-bot`
- Run: `make run` (or `go run ./cmd/betrayal-bot/main.go`)
- Discord:
  - Use `/tarot draw` with no options; confirm deterministic assignment stays the same for the same user/guild across invocations.
  - Use `/tarot draw mode:random` several times; observe varied cards.
  - Use `/tarot draw mode:per_user` twice; second call returns the same card; `/tarot reset scope:per_user user:@X` then draw again to see a new assignment.
  - Use `/tarot draw mode:guild_deck` repeatedly; verify no card repeats until exhaustion. When exhausted, confirm helpful error message. Admin runs `/tarot reset scope:guild_deck` and draws again.
  - Test `reversed:true` flag and verify orientation label and meaning switch.

Notes
- Default mode is deterministic by `guildID+userID` hash.
- In-memory state will reset on bot restart. If you want persistence, approve the Optional DB Persistence step and Iâ€™ll add migrations and sqlc models.

Implementation Details
- Arrays in `cards.go` are fixed-size and index-aligned; meanings pulled by the same index; always bounds-check.
- Deterministic hash helper:
  - `func hash64(s string) uint64 { h := fnv.New64a(); h.Write([]byte(s)); return h.Sum64() }`
- Map keys:
  - userAssignments: `userAssignments[guildID][userID] = assignment{idx, reversed}`
  - guildDeck: `deckState{remaining []int, dealt map[int]bool, orientation map[int]bool}`
- Concurrency: protect state with mutex; reads under RLock, writes under Lock.
